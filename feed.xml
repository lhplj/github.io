<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>lhplj</title>
    <link href="https://lhplj.github.io/feed.xml" rel="self" />
    <link href="https://lhplj.github.io" />
    <updated>2024-05-17T16:23:53+08:00</updated>
    <author>
        <name>lhplj</name>
    </author>
    <id>https://lhplj.github.io</id>

    <entry>
        <title>MergeSort</title>
        <author>
            <name>lhplj</name>
        </author>
        <link href="https://lhplj.github.io/mergesort.html"/>
        <id>https://lhplj.github.io/mergesort.html</id>

        <updated>2024-05-17T16:20:19+08:00</updated>
            <summary>
                <![CDATA[
                    归并排序时间复杂度O(N * logN) 优于冒泡/选择排序时间复杂度O(N^2) public class MergeSort { public static void main(String[] args) { int[] arr = {20, 24, 5, 17, 14, 25, 15, 52}; mergeSort1(arr); // mergeSort2(arr); } /** * 递归实现 */ private static void mergeSort1(int[] arr) { if (arr == null || arr.length&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>归并排序时间复杂度O(N * logN)</p>
<p>优于冒泡/选择排序时间复杂度O(N^2)</p>
<pre class="language-java"><code>public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {20, 24, 5, 17, 14, 25, 15, 52};
        mergeSort1(arr);
        //        mergeSort2(arr);
    }

    /**
     * 递归实现
     */
    private static void mergeSort1(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    private static void process(int[] arr, int l, int r) {
        if (l == r) {
            return;
        }
        // 将[l, r] 二分为 [l, m] 和 [m + 1, r]
        int m = l + (r - l &gt;&gt; 1);
        process(arr, l, m);
        process(arr, m + 1, r);
        merge(arr, l, m, r);
    }

    private static void merge(int[] arr, int l, int m, int r) {
        int[] help = new int[r - l + 1];
        // p1 指向[l,m]
        // p2 指向[m + 1, r]
        int i = 0, p1 = l, p2 = m + 1;
        while (p1 &lt;= m &amp;&amp; p2 &lt;= r) {
            // 比较左区间与右区间,直到某区间结束
            help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];
        }
        // 处理未结束的区间
        while (p1 &lt;= m) {
            help[i++] = arr[p1++];
        }
        while (p2 &lt;= r) {
            help[i++] = arr[p2++];
        }

        for (i = 0; i &lt; help.length; i++) {
            arr[l + i] = help[i];
        }
        System.out.println(JSON.toJSON(arr));
    }

    /**
     * 非递归实现
     */
    private static void mergeSort2(int[] arr) {
        if (arr == null || arr.length &lt; 2) {
            return;
        }
        int mergeSize = 1;
        int maxMergeSize = (arr.length &gt;&gt; 1) + 1;
        while (mergeSize &lt;= maxMergeSize) {
            int l = 0;
            while (l &lt; arr.length) {
                int m = l + mergeSize - 1;
                if (m &gt;= arr.length) {
                    break;
                }
                int r = Math.min(m + mergeSize, arr.length - 1);
                merge(arr, l, m, r);
                l = r + 1;
            }
            mergeSize &lt;&lt;= 1;
        }
    }
}
</code></pre>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Master公式</title>
        <author>
            <name>lhplj</name>
        </author>
        <link href="https://lhplj.github.io/mastergong-shi.html"/>
        <id>https://lhplj.github.io/mastergong-shi.html</id>

        <updated>2024-05-16T13:17:22+08:00</updated>
            <summary>
                <![CDATA[
                    形如T(N) = a * T(N/b) + O(N^d) 其中a/b/d都是常数的递归函数,可以直接通过Master公式来确定时间复杂度 如果log(b,a) &lt; d 复杂度为 O(N^d) 如果log(b,a) &gt; d 复杂度为 O(N^Log(b,a)) 如果log(b,a) = d 复杂度为 O(N^d * logN)
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>形如T(N) = a * T(N/b) + O(N^d) 其中a/b/d都是常数的递归函数,可以直接通过Master公式来确定时间复杂度</p>
<ol>
<li>如果log(b,a) &lt; d 复杂度为 O(N^d)</li>
<li>如果log(b,a) &gt; d 复杂度为 O(N^Log(b,a))</li>
<li>如果log(b,a) = d 复杂度为 O(N^d * logN)</li>
</ol>
            ]]>
        </content>
    </entry>
    <entry>
        <title>求整数二进制位最右(低)1的位置</title>
        <author>
            <name>lhplj</name>
        </author>
        <link href="https://lhplj.github.io/qiu-zheng-shu-er-jin-zhi-wei-zui-youdi1de-wei-zhi.html"/>
        <id>https://lhplj.github.io/qiu-zheng-shu-er-jin-zhi-wei-zui-youdi1de-wei-zhi.html</id>

        <updated>2024-05-15T14:59:17+08:00</updated>
            <summary>
                <![CDATA[
                    # 对于任意整数N,求N的二进制位最右1的位置 int pos = N &amp; ((~N) + 1); 对原数先取反再加1,最后再与原数进行与操作即可 使用场景 int count = 0; int rightOne = -1; while (N != 0) { # 找最后边为1的位置 rightOne = N &amp; ((~N) + 1); count++; # 将N中最后边的1消掉 N ^= rightOne; } 一个数组中有两种数是奇数个,找出这两种数 # 假设数组 arr&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <pre class="language-java"><code># 对于任意整数N,求N的二进制位最右1的位置
int pos = N &amp; ((~N) + 1);</code></pre>
<p>对原数先取反再加1,最后再与原数进行与操作即可</p>
<p>使用场景</p>
<ol>
<li>求整数N二进制中1的数量
<pre class="language-java"><code>int count = 0;
int rightOne = -1;
while (N != 0) {
    # 找最后边为1的位置
    rightOne = N &amp; ((~N) + 1);
    count++;
    # 将N中最后边的1消掉
    N ^= rightOne;
}</code></pre>
</li>
<li>一个数组中有两种数是奇数个,找出这两种数
<pre class="language-java"><code># 假设数组 arr 中的这两种数为 a 和 b
int eor = 0;
for (int i = 0; i &lt; arr.length; i++) {
    eor ^= arr[i];
}
# 此时 eor = a ^ b
# 因为 a != b 则 eor != 0 则必有二进制位有1
int rigthOne = eor &amp; ((~eor) + 1);
# 则对于 a 和 b 必有一个rigthOne 位置为1一个为 0
# 则必有 rightOne ^ a 和 rightOne ^ b 一个为1一个为0(可通过此方法将a与b分开)
int a = 0;
for (int i = 0; i &lt; arr.length; i++) {
    if (arr[i] &amp; rightOne != 0) {
        a ^= arr[i];
    }
}
int b = eor ^ a;</code></pre>
</li>
</ol>
            ]]>
        </content>
    </entry>
    <entry>
        <title>异或^</title>
        <author>
            <name>lhplj</name>
        </author>
        <link href="https://lhplj.github.io/yi-huo.html"/>
        <id>https://lhplj.github.io/yi-huo.html</id>

        <updated>2024-05-15T14:06:14+08:00</updated>
            <summary>
                <![CDATA[
                    异或运算符^运算规则:相同为0,不同为1 0 ^ 0 = 0; 1 ^ 1 = 0; 0 ^ 1 = 1; 1 ^ 0 = 1; 则对于任意整数N满足 N ^ N = 0; 0 ^ N = N; 进一步,对于任意整数M和N满足 M ^ N ^ N = M; N ^ M ^ N&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>异或运算符^运算规则:相同为0,不同为1</p>
<pre class="language-java"><code>0 ^ 0 = 0;
1 ^ 1 = 0;
0 ^ 1 = 1;
1 ^ 0 = 1;</code></pre>
<p>则对于任意整数N满足</p>
<pre class="language-java"><code>N ^ N = 0;
0 ^ N = N;</code></pre>
<p>进一步,对于任意整数M和N满足</p>
<pre class="language-java"><code>M ^ N ^ N = M;
N ^ M ^ N = M;</code></pre>
<p><strong>使用场景</strong></p>
<ol>
<li>数值交换
<pre class="language-java"><code># 交换 a 与 b 的值
int a = 7;
int b = 9;
# 正常数值交换,需要使用一个临时变量
int temp = a;
a = b;
b = temp;

# 通过异或
# a = 7 ^ 9;
a = a ^ b;
# b = 7 ^ 9 ^ 9 则 b = 7
b = a ^ b;
# a = 7 ^ 9 ^ 7 则 a = 9 完成交换
a = a ^ b;

# 注意事项: 通过异或交换数值时,要保证2个数指向的不是同一个地址</code></pre>
</li>
<li>一个数组中只有一种数有奇数个,找到这个数
<pre class="language-java"><code># 对于数组 arr 中只有一种数有奇数个,其它为偶数个
int eor = 0;
for (int i = 0; i &lt; arr.length; i++) {
    eor ^= arr[i];
}
# 最后 eor 就是要求的值</code></pre>
</li>
</ol>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>晶晶</title>
        <author>
            <name>lhplj</name>
        </author>
        <link href="https://lhplj.github.io/test.html"/>
        <id>https://lhplj.github.io/test.html</id>

        <updated>2024-05-14T18:19:10+08:00</updated>
            <summary>
                <![CDATA[
                    晶晶 爱你哟!
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>晶晶
爱你哟!</p>
            ]]>
        </content>
    </entry>
</feed>
