{
    "version": "https://jsonfeed.org/version/1",
    "title": "lhplj",
    "description": "",
    "home_page_url": "https://lhplj.github.io",
    "feed_url": "https://lhplj.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "lhplj"
    },
    "items": [
        {
            "id": "https://lhplj.github.io/mergesort.html",
            "url": "https://lhplj.github.io/mergesort.html",
            "title": "MergeSort",
            "summary": "归并排序时间复杂度O(N * logN) 优于冒泡/选择排序时间复杂度O(N^2) public class MergeSort { public static void main(String[] args) { int[] arr = {20, 24, 5, 17, 14, 25, 15, 52}; mergeSort1(arr); // mergeSort2(arr); } /** * 递归实现 */ private static void mergeSort1(int[] arr) { if (arr == null || arr.length&hellip;",
            "content_html": "<p>归并排序时间复杂度O(N * logN)</p>\n<p>优于冒泡/选择排序时间复杂度O(N^2)</p>\n<pre class=\"language-java\"><code>public class MergeSort {\n    public static void main(String[] args) {\n        int[] arr = {20, 24, 5, 17, 14, 25, 15, 52};\n        mergeSort1(arr);\n        //        mergeSort2(arr);\n    }\n\n    /**\n     * 递归实现\n     */\n    private static void mergeSort1(int[] arr) {\n        if (arr == null || arr.length &lt; 2) {\n            return;\n        }\n        process(arr, 0, arr.length - 1);\n    }\n\n    private static void process(int[] arr, int l, int r) {\n        if (l == r) {\n            return;\n        }\n        // 将[l, r] 二分为 [l, m] 和 [m + 1, r]\n        int m = l + (r - l &gt;&gt; 1);\n        process(arr, l, m);\n        process(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n\n    private static void merge(int[] arr, int l, int m, int r) {\n        int[] help = new int[r - l + 1];\n        // p1 指向[l,m]\n        // p2 指向[m + 1, r]\n        int i = 0, p1 = l, p2 = m + 1;\n        while (p1 &lt;= m &amp;&amp; p2 &lt;= r) {\n            // 比较左区间与右区间,直到某区间结束\n            help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];\n        }\n        // 处理未结束的区间\n        while (p1 &lt;= m) {\n            help[i++] = arr[p1++];\n        }\n        while (p2 &lt;= r) {\n            help[i++] = arr[p2++];\n        }\n\n        for (i = 0; i &lt; help.length; i++) {\n            arr[l + i] = help[i];\n        }\n        System.out.println(JSON.toJSON(arr));\n    }\n\n    /**\n     * 非递归实现\n     */\n    private static void mergeSort2(int[] arr) {\n        if (arr == null || arr.length &lt; 2) {\n            return;\n        }\n        int mergeSize = 1;\n        int maxMergeSize = (arr.length &gt;&gt; 1) + 1;\n        while (mergeSize &lt;= maxMergeSize) {\n            int l = 0;\n            while (l &lt; arr.length) {\n                int m = l + mergeSize - 1;\n                if (m &gt;= arr.length) {\n                    break;\n                }\n                int r = Math.min(m + mergeSize, arr.length - 1);\n                merge(arr, l, m, r);\n                l = r + 1;\n            }\n            mergeSize &lt;&lt;= 1;\n        }\n    }\n}\n</code></pre>",
            "author": {
                "name": "lhplj"
            },
            "tags": [
            ],
            "date_published": "2024-05-17T16:20:19+08:00",
            "date_modified": "2024-05-17T16:23:53+08:00"
        },
        {
            "id": "https://lhplj.github.io/mastergong-shi.html",
            "url": "https://lhplj.github.io/mastergong-shi.html",
            "title": "Master公式",
            "summary": "形如T(N) = a * T(N/b) + O(N^d) 其中a/b/d都是常数的递归函数,可以直接通过Master公式来确定时间复杂度 如果log(b,a) &lt; d 复杂度为 O(N^d) 如果log(b,a) &gt; d 复杂度为 O(N^Log(b,a)) 如果log(b,a) = d 复杂度为 O(N^d * logN)",
            "content_html": "<p>形如T(N) = a * T(N/b) + O(N^d) 其中a/b/d都是常数的递归函数,可以直接通过Master公式来确定时间复杂度</p>\n<ol>\n<li>如果log(b,a) &lt; d 复杂度为 O(N^d)</li>\n<li>如果log(b,a) &gt; d 复杂度为 O(N^Log(b,a))</li>\n<li>如果log(b,a) = d 复杂度为 O(N^d * logN)</li>\n</ol>",
            "author": {
                "name": "lhplj"
            },
            "tags": [
            ],
            "date_published": "2024-05-16T13:17:22+08:00",
            "date_modified": "2024-05-16T13:17:39+08:00"
        },
        {
            "id": "https://lhplj.github.io/qiu-zheng-shu-er-jin-zhi-wei-zui-youdi1de-wei-zhi.html",
            "url": "https://lhplj.github.io/qiu-zheng-shu-er-jin-zhi-wei-zui-youdi1de-wei-zhi.html",
            "title": "求整数二进制位最右(低)1的位置",
            "summary": "# 对于任意整数N,求N的二进制位最右1的位置 int pos = N &amp; ((~N) + 1); 对原数先取反再加1,最后再与原数进行与操作即可 使用场景 int count = 0; int rightOne = -1; while (N != 0) { # 找最后边为1的位置 rightOne = N &amp; ((~N) + 1); count++; # 将N中最后边的1消掉 N ^= rightOne; } 一个数组中有两种数是奇数个,找出这两种数 # 假设数组 arr&hellip;",
            "content_html": "<pre class=\"language-java\"><code># 对于任意整数N,求N的二进制位最右1的位置\nint pos = N &amp; ((~N) + 1);</code></pre>\n<p>对原数先取反再加1,最后再与原数进行与操作即可</p>\n<p>使用场景</p>\n<ol>\n<li>求整数N二进制中1的数量\n<pre class=\"language-java\"><code>int count = 0;\nint rightOne = -1;\nwhile (N != 0) {\n    # 找最后边为1的位置\n    rightOne = N &amp; ((~N) + 1);\n    count++;\n    # 将N中最后边的1消掉\n    N ^= rightOne;\n}</code></pre>\n</li>\n<li>一个数组中有两种数是奇数个,找出这两种数\n<pre class=\"language-java\"><code># 假设数组 arr 中的这两种数为 a 和 b\nint eor = 0;\nfor (int i = 0; i &lt; arr.length; i++) {\n    eor ^= arr[i];\n}\n# 此时 eor = a ^ b\n# 因为 a != b 则 eor != 0 则必有二进制位有1\nint rigthOne = eor &amp; ((~eor) + 1);\n# 则对于 a 和 b 必有一个rigthOne 位置为1一个为 0\n# 则必有 rightOne ^ a 和 rightOne ^ b 一个为1一个为0(可通过此方法将a与b分开)\nint a = 0;\nfor (int i = 0; i &lt; arr.length; i++) {\n    if (arr[i] &amp; rightOne != 0) {\n        a ^= arr[i];\n    }\n}\nint b = eor ^ a;</code></pre>\n</li>\n</ol>",
            "author": {
                "name": "lhplj"
            },
            "tags": [
            ],
            "date_published": "2024-05-15T14:59:17+08:00",
            "date_modified": "2024-05-15T15:19:20+08:00"
        },
        {
            "id": "https://lhplj.github.io/yi-huo.html",
            "url": "https://lhplj.github.io/yi-huo.html",
            "title": "异或^",
            "summary": "异或运算符^运算规则:相同为0,不同为1 0 ^ 0 = 0; 1 ^ 1 = 0; 0 ^ 1 = 1; 1 ^ 0 = 1; 则对于任意整数N满足 N ^ N = 0; 0 ^ N = N; 进一步,对于任意整数M和N满足 M ^ N ^ N = M; N ^ M ^ N&hellip;",
            "content_html": "<p>异或运算符^运算规则:相同为0,不同为1</p>\n<pre class=\"language-java\"><code>0 ^ 0 = 0;\n1 ^ 1 = 0;\n0 ^ 1 = 1;\n1 ^ 0 = 1;</code></pre>\n<p>则对于任意整数N满足</p>\n<pre class=\"language-java\"><code>N ^ N = 0;\n0 ^ N = N;</code></pre>\n<p>进一步,对于任意整数M和N满足</p>\n<pre class=\"language-java\"><code>M ^ N ^ N = M;\nN ^ M ^ N = M;</code></pre>\n<p><strong>使用场景</strong></p>\n<ol>\n<li>数值交换\n<pre class=\"language-java\"><code># 交换 a 与 b 的值\nint a = 7;\nint b = 9;\n# 正常数值交换,需要使用一个临时变量\nint temp = a;\na = b;\nb = temp;\n\n# 通过异或\n# a = 7 ^ 9;\na = a ^ b;\n# b = 7 ^ 9 ^ 9 则 b = 7\nb = a ^ b;\n# a = 7 ^ 9 ^ 7 则 a = 9 完成交换\na = a ^ b;\n\n# 注意事项: 通过异或交换数值时,要保证2个数指向的不是同一个地址</code></pre>\n</li>\n<li>一个数组中只有一种数有奇数个,找到这个数\n<pre class=\"language-java\"><code># 对于数组 arr 中只有一种数有奇数个,其它为偶数个\nint eor = 0;\nfor (int i = 0; i &lt; arr.length; i++) {\n    eor ^= arr[i];\n}\n# 最后 eor 就是要求的值</code></pre>\n</li>\n</ol>\n<p> </p>",
            "author": {
                "name": "lhplj"
            },
            "tags": [
            ],
            "date_published": "2024-05-15T14:06:14+08:00",
            "date_modified": "2024-05-15T14:39:35+08:00"
        },
        {
            "id": "https://lhplj.github.io/test.html",
            "url": "https://lhplj.github.io/test.html",
            "title": "晶晶",
            "summary": "晶晶 爱你哟!",
            "content_html": "<p>晶晶\n爱你哟!</p>",
            "author": {
                "name": "lhplj"
            },
            "tags": [
            ],
            "date_published": "2024-05-14T18:19:10+08:00",
            "date_modified": "2024-05-14T21:43:55+08:00"
        }
    ]
}
